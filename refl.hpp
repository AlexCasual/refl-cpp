/**
 * Created by veselink1.
 * Released under the MIT license.
 */

#ifndef REFL_INCLUDE_HPP
#define REFL_INCLUDE_HPP

// Support infrastructure for refl-ht
#ifdef REFL_PREPROCESSOR
#define REFL(...) typedef void __refl_autogenerated_marker__;
#else
#define REFL(...)
#endif 

#ifdef REFL_USE_NONSTD_MACRO
// The $refl(...) macro is now considered deprecated due to possible 
// problems with compilers (not the case with GCC, Clang, MSVC), but 
// also because it is non-standard.
#define $refl(...) REFL(__VA_ARGS__)
#endif

#ifdef REFL_USE_DEPRECATION_MACROS
// Ironically, these macros are now deprecated in favor of the
// bare [[deprecated]] attribute and the #warning macro directive.
#define REFL_UNSTABLE(...) [[deprecated("(unstable) " __VA_ARGS__)]]
#define REFL_DEPRECATED(...) [[deprecated(__VA_ARGS__)]]
#else
#define REFL_UNSTABLE(...) [[deprecated("REFL_UNSTABLE is now deprecated. To use it anyways define REFL_USE_DEPRECATION_MACROS.")]]
#define REFL_DEPRECATED(...) [[deprecated("REFL_DEPRECATED is now deprecated. To use it anyways define REFL_USE_DEPRECATION_MACROS.")]]
#endif

#ifndef REFL_PREPROCESSOR

#include <stddef.h> // size_t
#include <cstring>
#include <array>
#include <memory>
#include <utility> // std::move, std::forward
#include <optional>
#include <tuple>
#include <type_traits>
#include <ostream>
#include <sstream>
#include <iomanip> // std::quoted

#ifdef _MSC_VER
// Disable VS warning for "Not enough arguments for macro"
// (emitted when a REFL_ macro is not provided any attributes)
#pragma warning( disable : 4003 )
#endif

#if defined(__clang__)
  #if __has_feature(cxx_rtti)
    #define REFL_RTTI_ENABLED
  #endif
#elif defined(__GNUG__)
  #if defined(__GXX_RTTI)
    #define REFL_RTTI_ENABLED
  #endif
#elif defined(_MSC_VER)
  #if defined(_CPPRTTI)
    #define REFL_RTTI_ENABLED
  #endif
#endif

/// <summary>
/// using util::type_list; <br>
/// using descriptor::type_descriptor; <br>
/// using descriptor::field_descriptor; <br>
/// using descriptor::function_descriptor; <br>
/// using util::const_string; <br>
/// using util::make_const_string; <br>
/// </summary>
namespace refl
{
    namespace util
    {
        /// <summary>
        /// Represents a compile-time string. 
        /// </summary>
        template <size_t N>
        struct const_string
        {
            static constexpr size_t size = N; 

            char data[N + 1];

            constexpr const_string() noexcept = default;

            constexpr const_string(const char(&data)[N + 1]) noexcept
                : data{}
            {
                for (size_t i = 0; i < N; i++)
                    this->data[i] = data[i];
            }

            constexpr operator const char*() const noexcept
            {
                return data;
            }

            constexpr const char* c_str() const noexcept
            {
                return data;
            }

            std::string str() const noexcept
            {
                return data;
            }
            
        };

        /// <summary>
        /// Creates a compile-time string. 
        /// </summary>
        template <size_t N>
        constexpr const_string<N - 1> make_const_string(const char(&str)[N]) noexcept
        {
            return str;
        }

        /// <summary>
        /// Concats two const_strings together.
        /// </summary>
        template <size_t N, size_t M>
        constexpr const_string<N + M> operator+(const const_string<N>& a, const const_string<M>& b) noexcept
        {
            char data[N + M + 1] { };
            for (size_t i = 0; i < N; i++)
                data[i] = a.data[i];
            for (size_t i = 0; i < N; i++)
                data[N + i] = b.data[i];
            return data;
        }

        template <size_t N, size_t M>
        constexpr const_string<N + M - 1> operator+(const const_string<N>& a, const char(&b)[M]) noexcept
        {
            return a + make_const_string(b);
        }
        
        template <size_t N, size_t M>
        constexpr const_string<N + M - 1> operator+(const char(&a)[N], const const_string<M>& b) noexcept
        {
            return make_const_string(a) + b;
        }
        
        /// <summary>
        /// Compares two const_strings.
        /// </summary>
        template <size_t N, size_t M>
        constexpr bool operator==(const const_string<N>& a, const const_string<M>& b) noexcept
        {
            if constexpr (N != M) {
                return false;
            }
            else {
                for (size_t i = 0; i < M; i++) {
                    if (a[i] != b[i]) {
                        return false;
                    }
                }
                return true;
            }
        }

        /// <summary>
        /// Compares two const_strings.
        /// </summary>
        template <size_t N, size_t M>
        constexpr bool operator!=(const const_string<N>& a, const const_string<M>& b) noexcept
        {
            return !(a == b);
        }

        template <size_t N, size_t M>
        constexpr bool operator==(const const_string<N>& a, const char(&b)[M]) noexcept
        {
            return a == make_const_string(b);
        }

        template <size_t N, size_t M>
        constexpr bool operator!=(const const_string<N>& a, const char(&b)[M]) noexcept
        {
            return a != make_const_string(b);
        }
        
        template <size_t N, size_t M>
        constexpr bool operator==(const char(&a)[N], const const_string<M>& b) noexcept
        {
            return make_const_string(a) == b;
        }

        template <size_t N, size_t M>
        constexpr bool operator!=(const char(&a)[N], const const_string<M>& b) noexcept
        {
            return make_const_string(a) != b;
        }
        
    } // namespace util

    using util::const_string;
    using util::make_const_string;

    namespace detail::macro_exports
    {
    }
    
} // namespace refl

    namespace refl_impl
    {
        namespace metadata
        {
        using namespace refl::detail::macro_exports;

        /// <summary>
        /// The core reflection info type. 
        /// Should not be used by user code directly.
        /// </summary>
        template <typename T>
        struct type_info__
        {
            // Used for detecting this non-specialized type_info__. 
            struct invalid_marker{};

            // The names below are provided to support proper name-lookup. 
            // Otherwise, multiple errors will be generated, obscuring the actual
            // reason for the failiure.
            template <size_t, typename>
            struct member;
            
            static constexpr size_t member_count{ 0 };

            static constexpr refl::const_string<0> name{ "" };

            static constexpr std::tuple<> attributes{ };
        };

        // CV qualifiers are not taken into account when reflecting on a type.
        template <typename T>
        struct type_info__<const T> : public type_info__<T> {};

        template <typename T>
        struct type_info__<volatile T> : public type_info__<T> {};

        template <typename T>
        struct type_info__<const volatile T> : public type_info__<T> {};

        } // namespace metadata

    } // namespace refl_impl

namespace refl {

    namespace trait
    {
        /// <summary>
        /// Removes all reference and cv qualifiers of T.
        /// </summary>
        template <typename T>
        struct remove_qualifiers
        {
            typedef std::remove_cv_t<std::remove_reference_t<T>> type;
        };
        
        /// <summary>
        /// Removes all reference and cv qualifiers of T.
        /// </summary>
        template <typename T>
        using remove_qualifiers_t = typename remove_qualifiers<T>::type;

        namespace detail
        {
            template <typename T>
            decltype(typename refl_impl::metadata::type_info__<remove_qualifiers_t<T>>::invalid_marker{}, std::false_type{}) is_reflectable_test(int);
                
            template <typename T>
            std::true_type is_reflectable_test(...);
        }

        /// <summary>
        /// Checks whether the type T can be reflected.
        /// </summary>
        template <typename T>
        struct is_reflectable : decltype(detail::is_reflectable_test<T>(0))
        {
        };

        /// <summary>
        /// Checks whether the type T can be reflected.
        /// </summary>
        template <typename T>
        static constexpr bool is_reflectable_v{ is_reflectable<T>::value };

        namespace detail
        {
            template <typename U>
            static auto is_container_test(int) -> decltype(std::declval<U>().begin(), std::declval<U>().end(), std::true_type{});

            template <typename U>
            static std::false_type is_container_test(...);
        }

        /// <summary>
        /// Checks whether T supports begin() and end() member functions.
        /// </summary>
        template <typename T>
        struct is_container : decltype(detail::is_container_test<T>(0))
        {
        };

        /// <summary>
        /// Checks whether T supports begin() and end() member functions.
        /// </summary>
        template <typename T>
        static constexpr bool is_container_v{ is_container<T>::value };
    }

    /// <summary>
    /// An enumeration of the possible member types.
    /// </summary>
    namespace member
    {
        /// <summary>
        /// Represents a field.
        /// </summary>
        struct field {};

        /// <summary>
        /// Represents a function.
        /// </summary>
        struct function {};
    }

    namespace util
    {
        /// <summary>
        /// Represents a list of static types (implemented as variadic template parameters).
        /// </summary>
        template <typename... Ts>
        struct type_list
        {
            /// <summary>
            /// Represents the number of types in this type_list.
            /// </summary>
            static constexpr intptr_t size = sizeof...(Ts);
        };

    } // namespace util

    using util::type_list;

    namespace trait
    {
        namespace detail
        {
            template <size_t N, typename... Ts>
            struct get;

            template <size_t N>
            struct get<N>
            {
                static_assert(N > 0, "Missing arguments list for get<N, Ts...>!");
            };

            template <size_t N, typename T, typename... Ts>
            struct get<N, T, Ts...> : public get<N - 1, Ts...>
            {
            };

            template <typename T, typename... Ts>
            struct get<0, T, Ts...>
            {
                typedef T type;
            };

            static_assert(std::is_same_v<get<0, int>::type, int>, "Error!");
            static_assert(std::is_same_v<get<1, int, float>::type, float>, "Error!");

            template <size_t N, typename... Ts>
            struct skip;

            template <size_t N, typename T, typename... Ts>
            struct skip<N, T, Ts...> : public get<N - 1, Ts...>
            {
            };

            template <typename... Ts>
            struct skip<0, Ts...>
            {
                typedef type_list<Ts...> type;
            };
        }

        /// <summary>
        /// Accesses the N-th (0-based index) type in Ts...
        /// </summary>
        template <size_t N, typename... Ts>
        struct get : detail::get<N, Ts...>
        {
        };
        
        template <size_t N, typename... Ts>
        struct get<N, type_list<Ts...>> : detail::get<N, Ts...>
        {
        };

        /// <summary>
        /// Accesses the N-th (0-based index) type in Ts... (Ts may be a type_list<...> as well).
        /// </summary>
        template <size_t N, typename... Ts>
        using get_t = typename get<N, Ts...>::type;

        /// <summary>
        /// Skips the first N (0-based index) types in Ts... (Ts may be a type_list<...> as well).
        /// </summary>
        template <size_t N, typename... Ts>
        struct skip : detail::skip<N, Ts...>
        {
        };

        template <size_t N, typename... Ts>
        struct skip<N, type_list<Ts...>> : detail::skip<N, Ts...> 
        {
        };

        /// <summary>
        /// Skips the first N (0-based index) types in Ts... (Ts may be a type_list<...> as well).
        /// </summary>
        template <size_t N, typename... Ts>
        using skip_t = typename skip<N, Ts...>::type;

    } // namespace trait

	/// <summary>
	/// The built-in attributes as well as the attribute constraints in attr::usage.
	/// </summary>
    namespace attr
    {
		/// <summary>
		/// The attribute constraints.
		/// </summary>
        namespace usage
        {

            /// <summary>
            /// Specifies that an attribute type inheriting from this type can only be 
            /// used with REFL_TYPE(...).
            /// </summary>
            struct type {};

            /// <summary>
            /// Specifies that an attribute type inheriting from this type can only be 
            /// used with REFL_FUNC(...).
            /// </summary>
            struct function {};

            /// <summary>
            /// Specifies that an attribute type inheriting from this type can only be 
            /// used with REFL_FIELD(...).
            /// </summary>
            struct field {};

			/// <summary>
			/// Specifies that an attribute type inheriting from this type can only be 
			/// used with either REFL_FUNC(...), REFL_FIELD(...).
			/// </summary>
			struct member : public function, public field{};

			/// <summary>
			/// Specifies that an attribute type inheriting from this type can be used 
			/// with all three of REFL_FUNC, REFL_FIELD, REFL_FUNC.
			/// </summary>
			struct any : public member, public type {};
        }

        namespace detail
        {
            constexpr bool validate_unique(type_list<>) noexcept
            { 
                return true; 
            }

            /// <summary>
            /// Statically asserts that all arguments types in Ts... are unique.
            /// </summary>
            template <typename T, typename... Ts>
            constexpr bool validate_unique(type_list<T, Ts...>) noexcept
            {
                constexpr bool cond = (... && (!std::is_same_v<T, Ts> && validate_unique(type_list<Ts>{})));
                static_assert(cond, "Some of the attributes provided have duplicate types!");
                return cond;
            }

			template <typename Req, typename Attr>
			constexpr bool validate_usage() noexcept
			{
				return std::is_base_of_v<Req, Attr>;
			}

            template <typename Usage, typename... Args>
            constexpr std::tuple<std::remove_reference_t<Args>...> make_attributes(Args&&... args) noexcept
            {
                constexpr bool check_unique = validate_unique(type_list<Args...>{});
                static_assert(check_unique, "Some of the supplied attributes cannot be used on this declaration!");

                constexpr bool check_usage = (... && validate_usage<Usage, trait::remove_qualifiers_t<Args>>());
                static_assert(check_usage, "Some of the supplied attributes cannot be used on this declaration!");

                return std::tuple<std::remove_reference_t<Args>...>{ std::forward<Args>(args)... };
            }
        }
    } // namespace attr
    
    namespace detail
    {
        template <typename R, typename... Args>
        auto resolve(R(*fn)(Args...), Args&&... args) -> decltype(fn);

        #define REFL_DETAIL_QUALIFIED_RESOLVE(...) \
            template <typename R, typename T, typename... Args> \
            auto resolve(R(trait::remove_qualifiers_t<T>::*fn)(Args...) __VA_ARGS__, T&& target, Args&&... args) -> decltype(fn)
            
        REFL_DETAIL_QUALIFIED_RESOLVE();
        REFL_DETAIL_QUALIFIED_RESOLVE(const);
        REFL_DETAIL_QUALIFIED_RESOLVE(volatile);
        REFL_DETAIL_QUALIFIED_RESOLVE(const volatile);
        REFL_DETAIL_QUALIFIED_RESOLVE(&);
        REFL_DETAIL_QUALIFIED_RESOLVE(const&);
        REFL_DETAIL_QUALIFIED_RESOLVE(volatile&);
        REFL_DETAIL_QUALIFIED_RESOLVE(const volatile&);
        REFL_DETAIL_QUALIFIED_RESOLVE(&&);
        REFL_DETAIL_QUALIFIED_RESOLVE(const&&);
        REFL_DETAIL_QUALIFIED_RESOLVE(volatile&&);
        REFL_DETAIL_QUALIFIED_RESOLVE(const volatile&&);

        #undef REFL_DETAIL_QUALIFIED_RESOLVE
    }

#define REFL_DETAIL_STR_IMPL(...) #__VA_ARGS__
#define REFL_DETAIL_STR(...) REFL_DETAIL_STR_IMPL(__VA_ARGS__)
#define REFL_DETAIL_GROUP(...) __VA_ARGS__

#define REFL_DETAIL_ATTRIBUTES(DeclType, ...) \
        static constexpr auto attributes = ::refl::attr::detail::make_attributes<::refl::attr::usage:: DeclType>(__VA_ARGS__); \

#define REFL_DETAIL_TYPE_BODY(TypeName, ...) \
        typedef REFL_DETAIL_GROUP TypeName type; \
        REFL_DETAIL_ATTRIBUTES(type, __VA_ARGS__) \
    public: \
        static constexpr auto name{ ::refl::util::make_const_string(REFL_DETAIL_STR(REFL_DETAIL_GROUP TypeName)) }; \
        static constexpr size_t member_index_offset = __COUNTER__ + 1; \
        template <size_t N, typename = void> \
        struct member {}; 

/// <summary>
/// Creates reflection information for a specified type. Takes an optional attribute list. 
/// </summary>
#define REFL_TYPE(TypeName, ...) \
    namespace refl_impl::metadata { template<> struct type_info__<TypeName> { \
        REFL_DETAIL_TYPE_BODY((TypeName), __VA_ARGS__)

#define REFL_TEMPLATE(TemplateDeclaration, TypeName, ...) \
    namespace refl_impl::metadata { template <REFL_DETAIL_GROUP TemplateDeclaration> struct type_info__<REFL_DETAIL_GROUP TypeName> { \
        public: REFL_DETAIL_TYPE_BODY(TypeName, __VA_ARGS__)

#define REFL_END \
        static constexpr size_t member_count{ __COUNTER__ - member_index_offset }; \
    }; }
	

#define REFL_DETAIL_MEMBER_HEADER template<typename Unused__> struct member<__COUNTER__ - member_index_offset, Unused__>

#define REFL_DETAIL_MEMBER_COMMON(MemberType_, MemberName_, ...) \
        typedef type declaring_type; \
        typedef ::refl::member::MemberType_ member_type; \
        static constexpr auto name{ ::refl::util::make_const_string(REFL_DETAIL_STR(MemberName_)) }; \
        REFL_DETAIL_ATTRIBUTES(MemberType_, __VA_ARGS__) 

#define REFL_DETAIL_MEMBER_PROXY(MemberName_) \
        /* 
            There can be a total of 12 differently qualified member functions with the same name. 
            Providing remaps for non-const and const-only strikes a balance between compilation time and usability.
            And even though there are many other remap implementation possibilities (like virtual, field variants),
            adding them was considered to not be efficient from a compilation-time point of view.
        */ \
        template <typename Proxy> struct remap { \
            template <typename... Args> decltype(auto) MemberName_(Args&&... args) { \
                return Proxy::invoke_impl(static_cast<Proxy&>(*this), ::std::forward<Args>(args)...); \
            } \
            template <typename... Args> decltype(auto) MemberName_(Args&&... args) const { \
                return Proxy::invoke_impl(static_cast<const Proxy&>(*this), ::std::forward<Args>(args)...); \
            } \
        } \

/// <summary>
/// Creates reflection information for a public field. Takes an optional attribute list. 
/// </summary>
#define REFL_FIELD(FieldName_, ...) \
    REFL_DETAIL_MEMBER_HEADER { \
        REFL_DETAIL_MEMBER_COMMON(field, FieldName_, __VA_ARGS__) \
    public: \
        typedef decltype(type::FieldName_) value_type; \
        static constexpr auto pointer{ &type::FieldName_ }; \
        REFL_DETAIL_MEMBER_PROXY(FieldName_); \
    }; 

/// <summary>
/// Creates reflection information for a public function. Takes an optional *brace-enclosed* attribute list. 
/// </summary>
#define REFL_FUNC(FunctionName_, ...) \
    REFL_DETAIL_MEMBER_HEADER { \
        REFL_DETAIL_MEMBER_COMMON(function, FunctionName_, __VA_ARGS__) \
    public: \
        template <typename... Args> \
        static constexpr decltype(::refl::detail::resolve(&type::FunctionName_, std::declval<Args>()...)) pointer{ &type::FunctionName_ }; \
        REFL_DETAIL_MEMBER_PROXY(FunctionName_); \
    };

        namespace util
        {
            /// <summary>
            /// Ignores all arguments.
            /// </summary>
            template <typename T = int, typename... Ts>
            constexpr int ignore(Ts&&...) noexcept 
            {
                return {};
            }

            template <typename T>
            constexpr decltype(auto) identity(T&& t) noexcept
            {
                return t;
            }
            
            template <typename T>
            constexpr const T& make_const(const T& value) noexcept
            {
                return value;
            }
            
            template <typename T>
            constexpr const T& make_const(T& value) noexcept
            {
                return value;
            }
        } // namespace util

        namespace trait
        {
            namespace detail
            {
                template <typename, typename>
                struct cons;

                template <typename T, typename... Args>
                struct cons<T, type_list<Args...>>
                {
                    using type = type_list<T, Args...>;
                };

                template <template<typename> typename, typename...>
                struct filter_impl;

                template <template<typename> typename Predicate>
                struct filter_impl<Predicate>
                {
                    using type = type_list<>;
                };

                template <template<typename> typename Predicate, typename Head, typename ...Tail>
                struct filter_impl<Predicate, Head, Tail...>
                {
                    using type = std::conditional_t<Predicate<Head>::value,
                        typename cons<Head, typename filter_impl<Predicate, Tail...>::type>::type,
                        typename filter_impl<Predicate, Tail...>::type
                    >;
                };

                template <template<typename> typename Predicate, typename... Ts>
                struct filter_impl<Predicate, type_list<Ts...>> : public filter_impl<Predicate, Ts...>
                {
                };

                /// <summary>
                /// filters a type_list according to a Predicate (a type-trait-like template type).
                /// </summary>
                template <template<typename> typename Predicate>
                struct filter
                {
                    template <typename... Ts>
                    using apply = typename detail::filter_impl<Predicate, Ts...>::type;
                };

                template <template<typename> typename, typename...>
                struct map_impl;

                template <template<typename> typename Mapper>
                struct map_impl<Mapper>
                {
                    using type = type_list<>;
                };

                template <template<typename> typename Mapper, typename Head, typename ...Tail>
                struct map_impl<Mapper, Head, Tail...>
                {
                    using type = typename cons<typename Mapper<Head>::type, typename map_impl<Mapper, Tail...>::type>::type;
                };

                template <template<typename> typename Mapper, typename... Ts>
                struct map_impl<Mapper, type_list<Ts...>> : public map_impl<Mapper, Ts...>
                {
                };

                /// <summary>
                /// filters a type_list according to a Predicate (a type-trait-like template type).
                /// </summary>
                template <template<typename> typename Mapper>
                struct map
                {
                    template <typename... Ts>
                    using apply = typename detail::map_impl<Mapper, Ts...>::type;
                };
            }

            /// <summary>
            /// Filters a type_list according to a predicate template.
            /// </summary>
            template <template<typename> typename Predicate, typename... Ts>
            using filter = typename detail::filter<Predicate>::template apply<Ts...>;

            static_assert(std::is_same_v<filter<std::is_integral, int, float>, type_list<int>>);
            static_assert(std::is_same_v<filter<std::is_integral, type_list<int, float>>, type_list<int>>);

            /// <summary>
            /// Maps a type_list according to a predicate template.
            /// </summary>
            template <template<typename> typename Mapper, typename... Ts>
            using map = typename detail::map<Mapper>::template apply<Ts...>;

            static_assert(std::is_same_v<map<std::remove_reference, int&, float&>, type_list<int, float>>);
            static_assert(std::is_same_v<map<std::remove_reference, type_list<int&, float&>>, type_list<int, float>>);

        } // namespace trait

        namespace util
        {
            /// <summary>
            /// Creates an array of type 'T' from the provided tuple.
			/// The common type T needs to be specified, in order to prevent any 
			/// errors when using the overload taking an empty std::tuple (as there is no common type then). 
            /// </summary>
            template <typename T, typename... Ts>
            constexpr std::array<T, sizeof...(Ts)> to_array(const std::tuple<Ts...>& tuple) noexcept
            {
                return std::apply([](auto&& ... args) -> std::array<T, sizeof...(Ts)> { return { std::forward<decltype(args)>(args)... }; }, tuple);
            }

            static_assert(std::is_same_v<decltype(to_array<int>(std::make_tuple(0, 0))), std::array<int, 2>>);

            /// <summary>
            /// Creates an empty array of type 'T'.
            /// </summary>
            template <typename T>
            constexpr std::array<T, 0> to_array(const std::tuple<>& tuple) noexcept
            {
                return {};
            }

            static_assert(std::is_same_v<decltype(to_array<int>(std::tuple<>{})), std::array<int, 0>>);

			namespace detail
			{
				template <typename T, size_t... Idx>
				constexpr auto to_tuple(const std::array<T, sizeof...(Idx)>& array) noexcept
				{
					if constexpr (sizeof...(Idx) == 0) return std::tuple<>{};
					else return make_tuple(std::get<Idx>(array)...);
				}
			}

            /// <summary>
            /// Creates a tuple from the provided array.
            /// </summary>
            template <typename T, size_t N>
            constexpr auto to_tuple(const std::array<T, N>& array) noexcept
            {
                return detail::to_tuple<T, std::make_index_sequence<N>>(array);
            }

            namespace detail
            {
                
                template <typename F, typename... Carry>
                constexpr auto eval_in_order_to_tuple(type_list<>, std::index_sequence<>, F&& f, Carry&&... carry)
                {
                    if constexpr (sizeof...(Carry) == 0) return std::tuple<>{};
                    else return std::make_tuple(std::forward<Carry>(carry)...);
                }

                // This whole jazzy workaround is needed since C++ does not specify
                // the order in which function arguments are evaluated and this leads 
                // to incorrect order of evaluation (noticeable when using indexes).
                // Otherwise we could simply do std::make_tuple(f(Ts{}, Idx)...).
                template <typename F, typename T, typename... Ts, size_t I, size_t... Idx, typename... Carry>
                constexpr auto eval_in_order_to_tuple(type_list<T, Ts...>, std::index_sequence<I, Idx...>, F&& f, Carry&&... carry)
                {
                    if constexpr (std::is_invocable_v<F, T, size_t>) {
                        return eval_in_order_to_tuple(
                            type_list<Ts...>{},
                            std::index_sequence<Idx...>{}, 
                            std::forward<F>(f),
                            std::forward<Carry>(carry)..., // carry the previous results over
                            f(T{}, I) // pass the current result after them
                        );
                    }
                    else { 
                        return eval_in_order_to_tuple(
                            type_list<Ts...>{},
                            std::index_sequence<Idx...>{}, 
                            std::forward<F>(f),
                            std::forward<Carry>(carry)..., // carry the previous results over
                            f(T{}) // pass the current result after them
                        );
                    }
                }
            }

            /// <summary>
            /// Applies function F to each type in the type_list, aggregating
            /// the results in a tuple. F can optionally take an index of type size_t.
            /// </summary>
            template <typename F, typename... Ts>
            constexpr auto map_to_tuple(type_list<Ts...> list, F&& f)
            {
                return detail::eval_in_order_to_tuple(list, std::make_index_sequence<sizeof...(Ts)>{}, std::forward<F>(f));
            }

            static_assert(map_to_tuple(type_list<int>{}, [](auto t) { return t; }) == std::tuple<int>{ 0 });

            /// <summary>
            /// Applies function F to each type in the type_list, aggregating
            /// the results in an array. F can optionally take an index of type size_t.
            /// </summary>
            template <typename T, typename F, typename... Ts>
            constexpr auto map_to_array(type_list<Ts...> list, F&& f)
            {
                return to_array<T>(map_to_tuple(list, std::forward<F>(f)));
            }

            /// <summary>
            /// Applies function F to each type in the type_list.
            /// F can optionally take an index of type size_t.
            /// </summary>
            template <typename F, typename... Ts>
            constexpr void for_each(type_list<Ts...> list, F&& f)
            {
                map_to_tuple(list, [&](auto&&... args) -> decltype(f(std::forward<decltype(args)>(args)...), 0) 
                { 
                    f(std::forward<decltype(args)>(args)...); 
                    return 0; 
                });
            }
            
            /// <summary>
            /// Applies an accumulation function F to each type in the type_list.
            /// F can optionally take an index of type size_t.
            /// </summary>
            template <typename R, typename F, typename... Ts>
            constexpr R accumulate(type_list<Ts...> list, F&& f, R&& initial_value)
            {
                R r{ initial_value };
                for_each(list, [&](auto&&... args) -> decltype(f(r, std::forward<decltype(args)>(args)...), 0) 
                { 
                    f(r, std::forward<decltype(args)>(args)...); 
                    return 0; 
                });
                return r;
            }

            /// <summary>
            /// Applies an accumulation function F to each type in the type_list.
            /// F can optionally take an index of type size_t.
            /// </summary>
            template <typename F, typename... Ts>
            constexpr size_t count_if(type_list<Ts...> list, F&& f)
            {
                return accumulate<size_t>(list, [&](size_t& current, auto&&... args) -> decltype(f(std::forward<decltype(args)>(args)...), void(0))
                {
                    if (f(std::forward<decltype(args)>(args)...)) 
                    {
                        current += 1;
                    }
                }, 0);
            }

            namespace detail
            {
                template <typename F, typename... Carry>
                constexpr auto filter(F f, type_list<> list, type_list<Carry...> carry) 
                {
                    return carry;
                }

                template <typename F, typename T, typename... Ts, typename... Carry>
                constexpr auto filter(F f, type_list<T, Ts...> list, type_list<Carry...> carry) 
                {
                    if constexpr (f(T{})) {
                        return filter(f, type_list<Ts...>{}, type_list<T, Carry...>{});
                    } 
                    else {
                        return filter(f, type_list<Ts...>{}, type_list<Carry...>{});
                    }
                }
            }

            /// <summary>
            /// Filters the list according to a predicate.
            /// </summary>
            template <typename F, typename... Ts>
            constexpr auto filter(type_list<Ts...> list, F f) 
            {
                return detail::filter(f, list, type_list<>{});
            }
            
            /// <summary>
            /// Returns the first instance that matches the predicate. 
            /// </summary>
            template <typename F, typename... Ts>
            constexpr auto find_first(type_list<Ts...> list, F f) 
            {
                using result_list = decltype(detail::filter(f, list, type_list<>{}));
                return trait::get_t<0, result_list>{};
            }

            /// <summary>
            /// Returns the only instance that matches the predicate. If there is no match or multiple matches, fails with static_assert. 
            /// </summary>
            template <typename F, typename... Ts>
            constexpr auto find_one(type_list<Ts...> list, F f) 
            {
                using result_list = decltype(detail::filter(f, list, type_list<>{}));
                static_assert(result_list::size == 1, "Cannot resolve multiple matches in find_one!");
                return trait::get_t<0, result_list>{};
            }
        
            /// <summary>
            /// Returns the member that has the specified name. Fails with static_assert if not such member exists.
            /// </summary>
            template <size_t N, typename... Ts>
            constexpr auto find_one(type_list<Ts...> list, const const_string<N>& name) 
            {
                return find_one(list, [&](auto member) { return member.name == name; });
            }
            
            /// <summary>
            /// Returns true if any item in the list matches the predicate.
            /// </summary>
            template <typename F, typename... Ts>
            constexpr auto contains(type_list<Ts...> list, F f)
            {
                using result_list = decltype(detail::filter(f, list, type_list<>{}));
                return result_list::size > 0;
            }

            /// <summary>
            /// Returns true if any item in the list matches the predicate.
            /// </summary>
            template <size_t N, typename... Ts>
            constexpr auto contains(type_list<Ts...> list, const const_string<N>& name)
            {
                constexpr auto f = [&](auto member) { return member.name == name; };
                using result_list = decltype(detail::filter(f, list, type_list<>{}));
                return result_list::size > 0;
            }

            /// <summary>
            /// Applies a function to the elements of the type_list.
            /// </summary>
            template <typename... Ts, typename F>
            constexpr auto apply(type_list<Ts...> list, F&& f) 
            {
                return f(Ts{}...);
            }

        } // namespace util

        namespace trait
        {
            namespace detail
            {
                template <typename T>
                auto member_type_test(int) -> decltype(typename T::member_type{}, std::true_type{});

                template <typename T>
                std::false_type member_type_test(...);
            }

            template <typename T>
            struct is_member : decltype(detail::member_type_test<T>(0)) 
            {
            };

            template <typename T>
            static constexpr bool is_member_v{ is_member<T>::value };

            /// <summary>
            /// A trait for detecting whether the type 'T' is a field descriptor.
            /// </summary>
            template <typename T>
            struct is_field : std::conjunction<is_member<T>, std::is_base_of<typename T::member_type, member::field>>
            {
            };
            
            template <typename T>
            static constexpr bool is_field_v{ is_field<T>::value };

            /// <summary>
            /// A trait for detecting whether the type 'T' is a function descriptor.
            /// </summary>
            template <typename T>
            struct is_function : std::conjunction<is_member<T>, std::is_base_of<typename T::member_type, member::function>>
            {
            };

            template <typename T>
            static constexpr bool is_function_v{ is_function<T>::value };
        }
        
        namespace descriptor
        {
            template <typename T>
            class type_descriptor; 

            template <typename T, size_t N>
            class member_descriptor_base
            {
            protected:

                typedef typename refl_impl::metadata::type_info__<T>::template member<N> member;

            public:

                /// <summary>
                /// An alias for the declaring type of the reflected member.
                /// </summary>
                typedef T declaring_type;

                /// <summary>
                /// An alias, specifying the exact type of member.
                /// </summary>
                typedef typename member::member_type member_type;

                /// <summary>
                /// The type_descriptor of the declaring type.
                /// </summary>
                static constexpr type_descriptor<T> declarator{ };

                /// <summary>
                /// The name of the reflected member.
                /// </summary>
                static constexpr auto name{ member::name };

                /// <summary>
                /// The attributes of the reflected member.
                /// </summary>
                static constexpr auto attributes{ member::attributes };

            };
            

            /// <summary>
            /// Represents a reflected field.
            /// </summary>
            template <typename T, size_t N>
            class field_descriptor : public member_descriptor_base<T, N>
            {
                using typename member_descriptor_base<T, N>::member;
            public:

                /// <summary>
                /// Type value type of the member.
                /// </summary>
                typedef typename member::value_type value_type;
                
                static constexpr bool is_static{ !std::is_member_pointer_v<decltype(member::pointer)> };
                
                static constexpr auto pointer{ member::pointer };

                /// <summary>
                /// Returns the value of the field. (for static fields).
                /// </summary>
                static constexpr decltype(auto) get() noexcept
                {
                    return *member::pointer;
                }
                
                /// <summary>
                /// A synonym for get().
                /// </summary>
                constexpr decltype(auto) operator()() const noexcept
                {
                    return get();
                }

                /// <summary>
                /// Returns the value of the field. (for instance fields).
                /// </summary>
                template <typename U>
                static constexpr decltype(auto) get(U&& target) noexcept
                {
                    return target.*(member::pointer); 
                }
                
                /// <summary>
                /// A synonym for get(target).
                /// </summary>
                template <typename U>
                constexpr decltype(auto) operator()(U&& target) const noexcept
                {
                    return get(std::forward<U>(target));
                }

            };
            
            /// <summary>
            /// Represents a reflected function.
            /// </summary>
            template <typename T, size_t N>
            class function_descriptor : public member_descriptor_base<T, N>
            {
                using typename member_descriptor_base<T, N>::member;
                
                template <typename Fn, typename Self, typename... Args>
                static constexpr decltype(auto) invoke_impl(Fn trait::remove_qualifiers_t<Self>::* pointer, Self&& target, Args&&... args) 
                {
                    return (target.*pointer)(std::forward<Args>(args)...);
                }

            public:

                /// <summary>
                /// Gets a pointer to the function, deduced by the provided Args... template parameters. 
                /// For member functions the first type must be the target type. (possibly reference- or cv-qualified)
                /// </summary>
                template <typename... Args>
                static constexpr auto pointer{ member::template pointer<Args...> };

                /// <summary>
                /// Invokes the function with the given arguments. 
                /// If the function is an instance function, a reference
                /// to the instance is provided as first argument.
                /// </summary>
                template <typename... Args>
                static constexpr decltype(auto) invoke(Args&&... args)
                {
                    constexpr auto pointer = member::template pointer<Args...>;
                    if constexpr (std::is_member_function_pointer_v<decltype(pointer)>) {
                        return invoke_impl(pointer, std::forward<Args>(args)...);
                    } 
                    else {
                        return (*pointer)(std::forward<Args>(args)...);
                    }
                }
                
                /// <summary>
                /// A synonym for invoke(args...). 
                /// </summary>
                template <typename... Args>
                constexpr decltype(auto) operator()(Args&&... args) const
                {
                    return invoke(std::forward<Args>(args)...); 
                }

            };
        }

        using descriptor::field_descriptor;
        using descriptor::function_descriptor;

        namespace detail
        {
            template <typename T, size_t N>
            using make_descriptor = std::conditional_t<refl::trait::is_field_v<typename refl_impl::metadata::type_info__<T>::template member<N>>,
                field_descriptor<T, N>,
                std::conditional_t<refl::trait::is_function_v<typename refl_impl::metadata::type_info__<T>::template member<N>>,
                    function_descriptor<T, N>,
                    void
                >>;

			template <typename T, size_t... Idx>
			type_list<make_descriptor<T, Idx>...> enumerate_members(std::index_sequence<Idx...>);

		} // namespace detail
        
        /// <summary>
        /// A type_list of the member descriptors of the target type T. 
        /// </summary>
		template <typename T>
		using member_list = decltype(detail::enumerate_members<T>(std::make_index_sequence<refl_impl::metadata::type_info__<T>::member_count>{}));

        namespace descriptor
        {
            /// <summary>
            /// Represents a reflected type.
            /// </summary>
            template <typename T>
            class type_descriptor
            {
            private:

                static_assert(refl::trait::is_reflectable_v<T>, "This type does not support reflection!");

                typedef refl_impl::metadata::type_info__<T> type_info__;
                
            public:

                /// <summary>
                /// The list of member descriptors.
                /// </summary>
                static constexpr refl::member_list<T> members{  };

                /// <summary>
                /// The name of the reflected type.
                /// </summary>
                static constexpr const auto name{ type_info__::name };
                
                /// <summary>
                /// The attributes of the reflected type.
                /// </summary>
                static constexpr const auto attributes{ type_info__::attributes };

            };
        }
        
        using descriptor::type_descriptor;

        /// <summary>
        /// Returns true if the type T is reflectable.
        /// </summary>
        template <typename T>
        constexpr bool is_reflectable() noexcept
        {
            return trait::is_reflectable_v<T>;
        }
        
        /// <summary>
        /// Returns true if the type non-reference T is reflectable.
        /// </summary>
        template <typename T>
        constexpr bool is_reflectable(T&& t) noexcept
        {
            return trait::is_reflectable_v<trait::remove_qualifiers_t<T>>;
        }

        /// <summary>
        /// Returns the type descriptor for the type T. 
        /// </summary>
        template<typename T>
        constexpr type_descriptor<T> reflect() noexcept
        {
            return {};
        }

        /// <summary>
        /// Returns the type descriptor for the non-reference type T. 
        /// </summary>
        template<typename T>
        constexpr type_descriptor<std::remove_reference_t<T>> reflect(T&& t) noexcept
        {
            return {};
        }

        namespace trait
        {
            namespace detail
            {
                template <typename T>
                struct is_instance : public std::false_type {};

                template <template<typename...> typename T, typename... Args>
                struct is_instance<T<Args...>> : public std::true_type {};
            }

            /// <summary>
            /// True if T is a template specialization.
            /// </summary>
            template <typename T>
            struct is_instance : detail::is_instance<T>
            {
            };

            template <typename T>
            static constexpr bool is_instance_v{ is_instance<T>::value };

            namespace detail
            {
                template <template<typename...>  typename T, typename U>
                struct is_instance_of : public std::false_type {};

                template <template<typename...> typename T, template<typename...> typename U, typename... Args>
                struct is_instance_of<T, U<Args...>> : public std::is_same<T<Args...>, U<Args...>>
                {
                };
            }

            /// <summary>
            /// True if the type U is a template specialization of U.
            /// </summary>
            template <template<typename...>typename T, typename U>
            struct is_instance_of : detail::is_instance_of<T, U>
            {
            };

            template <template<typename...>typename T, typename U>
            static constexpr bool is_instance_of_v{ is_instance_of<T, U>::value };

            static_assert(is_instance_v<std::unique_ptr<int>>, "Error!");
            static_assert(is_instance_of_v<std::unique_ptr, std::unique_ptr<float>>, "Error!");

            namespace detail
            {   
                template <typename T, typename... Ts>
                struct contains_impl : std::disjunction<std::is_same<Ts, T>...>
                {
                };
                
                template <typename T, typename... Ts>
                struct contains_impl<T, type_list<Ts...>> : contains_impl<T, Ts...>
                {
                };
                
                template <typename T, typename... Ts>
                struct contains_impl<T, std::tuple<Ts...>> : contains_impl<T, Ts...>
                {
                };
                
                template <template<typename...> typename T, typename... Ts>
                struct contains_instance_impl : std::disjunction<trait::is_instance_of<T, Ts>...>
                {
                };
                
                template <template<typename...> typename T, typename... Ts>
                struct contains_instance_impl<T, type_list<Ts...>> : contains_instance_impl<T, Ts...>
                {
                };
                
                template <template<typename...> typename T, typename... Ts>
                struct contains_instance_impl<T, std::tuple<Ts...>> : contains_instance_impl<T, Ts...>
                {
                };
                
                template <typename T, typename... Ts>
                struct contains_base_impl : std::disjunction<std::is_base_of<Ts, T>...>
                {
                };

                template <typename T, typename... Ts>
                struct contains_base_impl<T, type_list<Ts...>> : contains_base_impl<T, Ts...>
                {
                };
                
                template <typename T, typename... Ts>
                struct contains_base_impl<T, std::tuple<Ts...>> : contains_base_impl<T, Ts...>
                {
                };
            }

            /// <summary>
            /// Checks whether T is contained in the list of types.
            /// </summary>
            template <typename T, typename... Ts>
            struct contains : detail::contains_impl<remove_qualifiers_t<T>, remove_qualifiers_t<Ts>...>
            {
            };

            template <typename T, typename... Ts>
            static constexpr bool contains_v = contains<T, Ts...>::value;

            /// <summary>
            /// Checks whether an instance of the tempalte T is contained in the list of types.
            /// </summary>
            template <template<typename...> typename T, typename... Ts>
            struct contains_instance : detail::contains_instance_impl<T, remove_qualifiers_t<Ts>...>
            {
            };
            
            /// <summary>
            /// Checks whether an instance of the tempalte T is contained in the list of types.
            /// </summary>
            template <template<typename...> typename T, typename... Ts>
            static constexpr bool contains_instance_v = contains_instance<T, Ts...>::value;

            /// <summary>
            /// Checks whether a type deriving from the type T is contained in the list of types.
            /// </summary>
            template <typename T, typename... Ts>
            struct contains_base : detail::contains_base_impl<remove_qualifiers_t<T>, remove_qualifiers_t<Ts>...>
            {
            };
            
            /// <summary>
            /// Checks whether a type deriving from the type T is contained in the list of types.
            /// </summary>
            template <typename T, typename... Ts>
            static constexpr bool contains_base_v = contains_base<T, Ts...>::value;

        } // namespace trait

        namespace util
        {
            namespace detail
            {
                template <template<typename...> typename T, ptrdiff_t N, typename... Ts>
                constexpr ptrdiff_t index_of_template() noexcept
                {
                    if constexpr (sizeof...(Ts) <= N)
                    {
                        return -1;
                    }
                    else if constexpr (trait::is_instance_of_v<T, trait::get_t<N, Ts...>>)
                    {
                        return N;
                    }
                    else 
                    {
                        return index_of_template<T, N + 1, Ts...>();
                    }
                }

                template <template<typename...> typename T, typename... Ts>
                constexpr ptrdiff_t index_of_template() noexcept
                {
                    if (!(... || trait::is_instance_of_v<T, Ts>)) return -1;
                    return index_of_template<T, 0, Ts...>();
                }

                template <typename T>
                struct index_of_test {};

                static_assert(!trait::contains_instance_v<index_of_test, std::tuple<int>>, "Error!");
                static_assert(index_of_template<index_of_test, int>() == -1, "Error!");
                static_assert(index_of_template<index_of_test, index_of_test<int>>() == 0, "Error!");
                static_assert(index_of_template<index_of_test, int, index_of_test<int>>() == 1, "Error!");
            }

            /// <summary>
            /// A synonym for std::get<T>(tuple).
            /// </summary>
            template <typename T, typename... Ts>
            constexpr const auto& get(const std::tuple<Ts...>& ts) noexcept
            {
                return std::get<T>(ts);
            }

            /// <summary>
            /// Returns the value of type U, where U is a template instance of T.
            /// </summary>
            template <template<typename...> typename T, typename... Ts>
            constexpr const auto& get_instance(const std::tuple<Ts...>& ts) noexcept
            {
                static_assert((... || trait::is_instance_of_v<T, Ts>), "The tuple does not contain a type that is a template instance of T!");
                constexpr size_t idx = static_cast<size_t>(detail::index_of_template<T, Ts...>());
                return std::get<idx>(ts);
            }

        } // namespace util

        namespace attr
        {
            enum class access_type 
            {
                read = 0b1,
                write = 0b10,
                read_write = read | write,
            };

            static constexpr auto read_only = access_type::read;
            static constexpr auto write_only = access_type::write;
            static constexpr auto read_write = access_type::read_write;

            /// <summary>
            /// Used to decorate a member that serves as a property. 
            /// Takes an optional friendly name.
            /// </summary>
            struct property : public usage::field, public usage::function
            {
                const access_type access{ access_type::read_write };
                const std::optional<const char*> friendly_name{};

                constexpr property() noexcept = default;
                
                constexpr property(access_type access) noexcept
                    : access(access)
                    , friendly_name()
                {
                }

                constexpr property(const char* friendly_name) noexcept
                    : access(access_type::read_write)
                    , friendly_name(friendly_name)
                {
                }
                
                constexpr property(access_type access, const char* friendly_name) noexcept
                    : access(access)
                    , friendly_name(friendly_name)
                {
                }
            };

            /// <summary>
            /// Used to specify how a type should be displayed in debugging contexts.
            /// </summary>
            template <typename F>
            struct debug : public usage::any
            {
                const F write;

                constexpr debug(F write)
                    : write(write)
                {
                }
            };

            /// <summary>
            /// Used to specify the base types of the target type.
            /// </summary>
            template <typename... Ts>
            struct base_types : usage::type
            {
                typedef type_list<Ts...> list_type;
                static constexpr list_type list{ };
            };

            /// <summary>
            /// Used to specify the base types of the target type.
            /// </summary>
            template <typename... Ts>
            static constexpr base_types<Ts...> bases{ };

        } // namespace attr

        namespace detail::macro_exports
        {
            using attr::read_only;
            using attr::write_only;
            using attr::read_write;
            using attr::property;
            using attr::debug;
            using attr::bases;
        }

        namespace trait
        {
            /// <summary>
            /// Checks whether T is marked as a property.
            /// </summary>
            template <typename T>
            struct is_property : std::bool_constant<
                (trait::is_field_v<T> || trait::is_function_v<T>) 
                    && trait::contains_v<attr::property, std::remove_cv_t<decltype(T::attributes)>>> 
            {
            };

            /// <summary>
            /// Checks whether T is marked as a property.
            /// </summary>
            template <typename T>
            static constexpr bool is_property_v{ is_property<T>::value };
        }

        namespace descriptor
        {
            /// <summary>
            /// Checks whether T is a field descriptor. 
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <typename T>
            constexpr bool is_field(T&& t) noexcept
            {
                return trait::is_field_v<std::remove_reference_t<T>>;
            }
            
            /// <summary>
            /// Checks whether T is a function descriptor. 
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <typename T>
            constexpr bool is_function(T&& t) noexcept
            {
                return trait::is_function_v<std::remove_reference_t<T>>;
            }

            /// <summary>
            /// Checks whether T has an attribute of type A. 
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <typename A, typename T>
            constexpr bool has_attribute(T&& t) noexcept
            {
                return trait::contains_base_v<A, std::remove_cv_t<decltype(t.attributes)>>;
            }
            
            /// <summary>
            /// Checks whether T has an attribute of that is a template instance of A. 
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <template<typename...> typename A, typename T>
            constexpr bool has_attribute(T&& t) noexcept
            {
                return trait::contains_instance_v<A, std::remove_cv_t<decltype(t.attributes)>>;
            }
            
            /// <summary>
            /// Checks whether T is a property descriptor. 
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <typename T>
            constexpr bool is_property(T&& t) noexcept
            {
                return has_attribute<attr::property>(t);
            }
            
            /// <summary>
            /// Returns the value of the attribute A on T. 
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <typename A, typename T>
            constexpr const A& get_attribute(T&& t) noexcept
            {
                return util::get<A>(t.attributes);
            }
            
            /// <summary>
            /// Returns the value of the attribute A on T. 
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <template<typename...> typename A, typename T>
            constexpr const auto& get_attribute(T&& t) noexcept
            {
                return util::get_instance<A>(t.attributes);
            }
            
            /// <summary>
            /// Gets the property attribute.
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <typename T>
            constexpr attr::property get_property_info(T&& t) noexcept
            {
                return get_attribute<attr::property>(t);
            }
            
            /// <summary>
            /// Checks if the property T is readable.
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <typename T>
            constexpr bool is_readable(T&& t) noexcept
            {
                using no_ref_t = std::remove_reference_t<T>;
                static_assert(trait::is_field_v<no_ref_t> || trait::is_property_v<no_ref_t>);
                if constexpr (trait::is_property_v<no_ref_t>) {
                    return static_cast<unsigned>(get_property_info(t).access) 
                        & static_cast<unsigned>(attr::access_type::read);
                }
                else {
                    return true;
                }
            }
            
            /// <summary>
            /// Checks if the property T is writable.
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <typename T>
            constexpr bool is_writable(T&& t) noexcept
            {
                using no_ref_t = std::remove_reference_t<T>;
                static_assert(trait::is_field_v<no_ref_t> || trait::is_property_v<no_ref_t>);
                if constexpr (trait::is_property_v<no_ref_t>) {
                    return static_cast<unsigned>(get_property_info(t).access) 
                        & static_cast<unsigned>(attr::access_type::write);
                }
                else {
                    return !std::is_const_v<typename trait::remove_qualifiers_t<T>::value_type>;
                }
            }

            /// <summary>
            /// Returns the debug name of T. (In the form of 'declaring_type::member_name').
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
            template <typename T>
			const char* get_debug_name(T&& t)
			{
                static const std::string name(std::string(t.declarator.name) + "::" + t.name.str());
				return name.c_str();
			}

            /// <summary>
            /// Returns the display name of T. 
            /// (Uses the friendly_name of the property attribute or falls back to the in-code name). 
            /// (Tip: Take advantage ADL-lookup whenever possible.)
            /// </summary>
			template <typename T>
			const char* get_display_name(T&& t) noexcept
			{
				if constexpr (trait::is_property_v<std::remove_reference_t<T>>) {
					auto&& friendly_name = util::get<attr::property>(t.attributes).friendly_name;
					return friendly_name ? *friendly_name : t.name;
				}
				return t.name;
			}

            /// <summary>
            /// Creates a function object that dispatches to the approprite invocation function of T.
            /// </summary>
			template <typename T>
			constexpr auto make_invoker(T&& t) noexcept
			{
				using descriptor_type = std::remove_reference_t<T>;
				return [](auto&&... args) -> decltype(auto) {
                    static_assert(is_field(descriptor_type{}) || is_function(descriptor_type{}), "Invalid field or function descriptor!");
                    return descriptor_type{}(std::forward<decltype(args)>(args)...);
                };
			}

        } // namespace descriptor

#ifndef REFL_DETAIL_FORCE_EBO
#ifdef _MSC_VER
#define REFL_DETAIL_FORCE_EBO __declspec(empty_bases)
#else
#define REFL_DETAIL_FORCE_EBO 
#endif
#endif

        namespace runtime
        {

            namespace detail
            {
                template <typename T>
                struct get_member_info;
                
                template <typename T, size_t N>
                struct get_member_info<refl::function_descriptor<T, N>>
                {
                    using type = typename refl_impl::metadata::type_info__<T>::template member<N>;
                };
                
                template <typename T, size_t N>
                struct get_member_info<refl::field_descriptor<T, N>>
                {
                    using type = typename refl_impl::metadata::type_info__<T>::template member<N>;
                };

                template <typename T, typename U>
                constexpr T& static_ref_cast(U& value) noexcept 
                {
                    return static_cast<T&>(value);
                }

                template <typename T, typename U>
                constexpr const T& static_ref_cast(const U& value) noexcept 
                {
                    return static_cast<const T&>(value);
                }

                /// <summary>
                /// Implements a proxy for a reflected function.
                /// </summary>
                template <typename Derived, typename Func>
                struct REFL_DETAIL_FORCE_EBO function_proxy : public get_member_info<Func>::type::template remap<function_proxy<Derived, Func>>
                {
                    function_proxy()
                    {
                    }

                    template <typename Self, typename... Args>
                    static constexpr decltype(auto) invoke_impl(Self&& self, Args&& ... args)
                    {
                        return Derived::template invoke_impl<Func>(static_ref_cast<Derived>(self), std::forward<Args>(args)...);
                    }

                };

                template <typename, typename>
                struct REFL_DETAIL_FORCE_EBO function_proxies;

                /// <summary>
                /// Implements a proxy for all reflected functions.
                /// </summary>
                template <typename Derived, typename... Members>
                struct REFL_DETAIL_FORCE_EBO function_proxies<Derived, type_list<Members...>> : public function_proxy<Derived, Members>...
                {
                };
                
                /// <summary>
                /// Implements a proxy for a reflected field.
                /// </summary>
                template <typename Derived, typename Field>
                struct REFL_DETAIL_FORCE_EBO field_proxy : public get_member_info<Field>::type::template remap<field_proxy<Derived, Field>>
                {
                    field_proxy()
                    {
                    }

                    template <typename Self, typename... Args>
                    static constexpr decltype(auto) invoke_impl(Self&& self, Args&& ... args)
                    {
                        return Derived::template invoke_impl<Field>(static_ref_cast<Derived>(self), std::forward<Args>(args)...);
                    }

                };
                

                template <typename, typename>
                struct REFL_DETAIL_FORCE_EBO field_proxies;

                /// <summary>
                /// Implements a proxy for all reflected functions.
                /// </summary>
                template <typename Derived, typename... Members>
                struct REFL_DETAIL_FORCE_EBO field_proxies<Derived, type_list<Members...>> : public field_proxy<Derived, Members>...
                {
                };

				template <typename T>
				using functions = trait::filter<trait::is_function, member_list<std::remove_reference_t<T>>>;
                
				template <typename T>
				using fields = trait::filter<trait::is_field, member_list<std::remove_reference_t<T>>>;

            } // namespace detail
            
            /// <summary>
            /// A proxy object that has a static interface identical to the reflected functions and fields of type T.
            /// Users should inherit from this class and specify a invoke_impl(Member member, Args&&... args) function.
            /// </summary>
            template <typename Derived, typename Target>
            struct REFL_DETAIL_FORCE_EBO proxy 
                : public detail::function_proxies<proxy<Derived, Target>, detail::functions<Target>>
                , public detail::field_proxies<proxy<Derived, Target>, detail::fields<Target>>
            {
                static_assert(
                    sizeof(detail::function_proxies<proxy<Derived, Target>, detail::functions<Target>>) == 1,
                    "Multiple inheritance EBO did not kick in! "
                    "You could try defining the REFL_DETAIL_FORCE_EBO macro appropriately to enable it on the required types. "
                    "Default for MSC is `__declspec(empty_bases)`.");

                static_assert(
                    trait::is_reflectable_v<Target>,
                    "Target type must be reflectable!");

                typedef Target target_type;

                constexpr proxy() noexcept {}

            private:

                template <typename P, typename F>
                friend struct detail::function_proxy;
                
                template <typename P, typename F>
                friend struct detail::field_proxy;

                // Called by one of the function_proxy/field_proxy bases.
                template <typename Member, typename Self, typename... Args>
                static constexpr decltype(auto) invoke_impl(Self&& self, Args&& ... args)
                {
                    return Derived::template invoke_impl<Member>(detail::static_ref_cast<Derived>(self), std::forward<Args>(args)...);
                }

            };

        } // namespace runtime

        namespace trait
        {
            template <typename>
            struct is_proxy;
            
            template <typename T>
            struct is_proxy
            {
            private:
                template <typename Derived, typename Target>
                static std::true_type test(runtime::proxy<Derived, Target>*);
                static std::false_type test(...);
            public:
                static constexpr bool value{ !std::is_reference_v<T> && decltype(test(std::declval<remove_qualifiers_t<T>*>()))::value };
            };

            template <typename T>
            static constexpr bool is_proxy_v{ is_proxy<T>::value };
        }

        namespace runtime
        {
            template <typename T>
            void debug(std::ostream& os, const T& value);

            template <typename T>
            void debug(std::ostream& os, const T& value, bool compact);

            namespace detail
            {
                template <typename T, typename Member>
                void debug_member(std::ostream& os, const T& value, Member member, bool compact)
                {
                    static_assert(is_readable(member));
                    std::string name{ get_display_name(member) };

                    if (!compact) os << "  ";
                    os << name << " = ";

                    if constexpr (trait::contains_instance_v<attr::debug, decltype(member.attributes)>) {
                        auto&& dbg_attr = util::get_instance<attr::debug>(member.attributes);
                        auto&& prop_value = member(value);
                        
                        if constexpr (trait::is_reflectable_v<trait::remove_qualifiers_t<decltype(prop_value)>>()) {
                            if (!compact) {
                                os << "(" << reflect(prop_value).name << ")";
                            }
                            else {
                                os << "(<?>)";
                            }
                        }
                        dbg_attr.write(os, prop_value);
                    }
                    else {
                        auto&& prop_value = member(value);
                        if constexpr (trait::is_reflectable_v<trait::remove_qualifiers_t<decltype(prop_value)>>()) {
                            if (!compact) {
                                os << "(" << reflect(prop_value).name << ")";
                            }
                            debug(os, prop_value, true);
                        }
                        else {
                            os << "<?>";
                        }
                    }
                }
            }

            /// <summary>
            /// Writes the debug representation of value to the given std::ostream.
            /// </summary>
            template <typename T>
            void debug(std::ostream& os, const T& value, bool compact)
            {
				static_assert(trait::is_reflectable_v<T> || trait::is_container_v<T>, 
                    "Type is neither reflectable nor a container of reflectable types!");

				if constexpr (trait::is_reflectable_v<T>) {
				    typedef type_descriptor<T> type_descriptor;
					if constexpr (trait::contains_instance_v<attr::debug, decltype(type_descriptor::attributes)>) {
						auto debug = util::get_instance<attr::debug>(type_descriptor::attributes);
						debug.write(os, value);
					}
					else if constexpr (std::is_fundamental_v<T>) {
						std::ios_base::fmtflags old_flags{ os.flags() };
						os << std::boolalpha << value;
						os.flags(old_flags);
					}
					else if constexpr (std::is_pointer_v<T>) {
                        if (!compact) {
                            os << "(" << reflect<std::remove_pointer_t<T>>().name << "*)";
                        }
                        if (value) {
                            os << '&';
                            runtime::debug(os, *value, true);
                        }
                        else {
                            os << "nullptr";
                        }
					}
					else {
						os << "{ ";
						if (!compact) os << "\n";
                        constexpr size_t count = count_if(type_descriptor::members, [](auto member) { return is_readable(member); });
						for_each(type_descriptor::members, [&](auto member, auto index) {
							if constexpr (is_readable(member)) {
								detail::debug_member(os, value, member, compact);
                                if (index + 1 != count) {
                                    os << ", ";
                                }
                                if (!compact) os << "\n";
							}
						});

						if (compact) os << " }";
						else os << "}";
					}
				}
				else { // T supports begin() and end()
					os << "[";
					auto end = value.end();
					for (auto it = value.begin(); it != end; ++it)
					{
						debug(os, *it, true);
						if (std::next(it, 1) != end)
						{
							os << ", ";
						}
					}
					os << "]";
				}
            }
            
            /// <summary>
            /// Writes the debug representation of the provided values to the given std::ostream.
            /// </summary>
            template <typename T>
            void debug(std::ostream& os, const T& value)
            {
                debug(os, value, false);
            }

            /// <summary>
            /// Writes the (compact) debug representation of the provided values to the given std::ostream.
            /// </summary>
            template <typename... Ts>
            void debug_all(std::ostream& os, const Ts&... values) {
                refl::runtime::debug(os, std::forward_as_tuple(static_cast<const Ts&>(values)...), true);
            }

            /// <summary>
            /// Writes the (compact) debug representation of the provided value to an std::string and returns it.
            /// </summary>
            template <typename T>
            std::string debug_str(const T& value, bool compact = false)
            {
                std::stringstream ss;
                debug(ss, value, compact);
                return ss.str();
            }
            
            /// <summary>
            /// Writes the (compact) debug representation of the provided values to an std::string and returns it.
            /// </summary>
            template <typename... Ts>
            std::string debug_all_str(const Ts&... values) {
                return refl::runtime::debug_str(std::forward_as_tuple(static_cast<const Ts&>(values)...), true);
            }

            /// <summary>
            /// Invokes the specified member. 
            /// When used with a member that is a field, the function gets or sets the value of the field.
            /// </summary>
            template <typename U, typename T, typename... Args>
            U invoke(T&& target, const char* name, Args&&... args)
            {
				using type = std::remove_reference_t<T>;
                static_assert(refl::trait::is_reflectable_v<type>, "Unsupported type!");
                typedef type_descriptor<type> type_descriptor;
                
                std::optional<U> result;

				bool found{ false };
				for_each(type_descriptor::members, [&](auto member) {
					if (found) return;

					constexpr auto invoker = make_invoker(member);
					using invoker_type = decltype(invoker);

					if constexpr (std::is_invocable_r_v<U, invoker_type, T, Args...>(member)) {
						if (std::strcmp(member.name, name) == 0) {
							result.emplace(invoker(target, std::forward<Args>(args)...));
							found = true;
						}
					}
				});

                if (found) {
                    return std::move(*result);
                }
                else {
                    throw std::runtime_error(std::string("The member ")
                        + type_descriptor::name.str() + "::" + name
                        + " is not compatible with the provided parameters or return type, is not reflected or does not exist!");
                }
            }

        } // namespace runtime

        namespace prelude 
        {
            using namespace descriptor;
            using namespace util;
            using namespace runtime;
        } // namespace prelude

} // namespace refl

#define REFL_DETAIL_PRIMITIVE(TypeName) \
    REFL_TYPE(TypeName) \
    REFL_END

    // Char types.
    REFL_DETAIL_PRIMITIVE(char);
    REFL_DETAIL_PRIMITIVE(wchar_t);
    REFL_DETAIL_PRIMITIVE(char16_t);
    REFL_DETAIL_PRIMITIVE(char32_t);
#ifdef __cpp_lib_char8_t
    REFL_DETAIL_PRIMITIVE(char8_t);
#endif 

    // Integral types.
    REFL_DETAIL_PRIMITIVE(bool);
    REFL_DETAIL_PRIMITIVE(signed char);
    REFL_DETAIL_PRIMITIVE(unsigned char);
    REFL_DETAIL_PRIMITIVE(signed short);
    REFL_DETAIL_PRIMITIVE(unsigned short);
    REFL_DETAIL_PRIMITIVE(signed int);
    REFL_DETAIL_PRIMITIVE(unsigned int);
    REFL_DETAIL_PRIMITIVE(signed long);
    REFL_DETAIL_PRIMITIVE(unsigned long);
    REFL_DETAIL_PRIMITIVE(signed long long);
    REFL_DETAIL_PRIMITIVE(unsigned long long);
    
    // Floating point types.
    REFL_DETAIL_PRIMITIVE(float);
    REFL_DETAIL_PRIMITIVE(double);
    REFL_DETAIL_PRIMITIVE(long double);

    // Other types.
    REFL_DETAIL_PRIMITIVE(decltype(nullptr));

    // Void type.
    REFL_TYPE(void)
    REFL_END

#undef REFL_DETAIL_PRIMITIVE

#define REFL_DETAIL_POINTER(Ptr) \
        template<typename T> \
        struct type_info__<T Ptr> { \
            typedef T Ptr type; \
            template <size_t N> \
            struct member {}; \
            static constexpr auto name{ ::refl::util::make_const_string(#Ptr) }; \
            static constexpr ::std::tuple<> attributes{ }; \
            static constexpr size_t member_count{ 0 }; \
        }

    namespace refl_impl::metadata
    {
        REFL_DETAIL_POINTER(*);
        REFL_DETAIL_POINTER(&);
        REFL_DETAIL_POINTER(&&);
    }

#undef REFL_DETAIL_POINTER

    static_assert(refl::trait::is_reflectable_v<void>, "Static assertion failed!");
    static_assert(refl::trait::is_reflectable_v<int*>, "Static assertion failed!");
    static_assert(refl::trait::is_reflectable_v<int&>, "Static assertion failed!");
    static_assert(refl::trait::is_reflectable_v<int&&>, "Static assertion failed!");

namespace refl::detail
{
    template <typename T>
    auto write_impl(std::ostream& os, T&& t) -> decltype((os << t), void())
    {
        os << t;
    }

	template <typename T>
	void write_impl(std::ostream& os, const volatile T* ptr)
	{
		auto f(os.flags());
		os << "(" << reflect<T>().name << "*)" << std::hex << ptr;
		os.flags(f);
	}

	inline void write_impl(std::ostream& os, const char* ptr)
	{
		os << ptr;
	}

	inline void write_impl(std::ostream& os, const std::exception& e)
	{
		os << "Exception";
#ifdef REFL_RTTI_ENABLED
		os << " (" << typeid(e).name() << ")";
#endif
		os << ": `" << e.what() << "`";
	}

	inline void write_impl(std::ostream& os, const std::string& t)
	{
		os << std::quoted(t);
	}

	inline void write_impl(std::ostream& os, const std::wstring& t)
	{
#ifdef _MSC_VER
// Disable the "wcsrtombs is unsafe" warning in VS
#pragma warning(push)
#pragma warning(disable:4996)
#endif
		std::mbstate_t state = std::mbstate_t();
		const wchar_t* wsptr = t.c_str();
		std::size_t len = 1 + std::wcsrtombs(nullptr, &wsptr, 0, &state);

		std::string mbstr(len, '\0');
		std::wcsrtombs(mbstr.data(), &wsptr, mbstr.size(), &state);

		os << std::quoted(mbstr);
#ifdef _MSC_VER
#pragma warning(pop)
#endif
	}

    template <typename Tuple, size_t... Idx>
    void write_impl(std::ostream& os, Tuple&& t, std::index_sequence<Idx...>)
    {
        os << "(";
        refl::util::ignore((os << std::get<Idx>(t))...);
        os << ")";
    }

    template <typename... Ts>
    void write_impl(std::ostream& os, const std::tuple<Ts...>& t)
    {
        write_impl(os, t, std::make_index_sequence<sizeof...(Ts)>{});
    }

	template <typename K, typename V>
	void write_impl(std::ostream& os, const std::pair<K, V>& t);

    template <typename K, typename V>
    void write_impl(std::ostream& os, const std::pair<K, V>& t)
    {
        os << "(";
        write(os, t.first);
        os << ", ";
        write(os, t.second);
        os << ")";
    }
    
    template <typename T, typename D>
    void write_impl(std::ostream& os, const std::unique_ptr<T, D>& t)
    {
        os << "(std::unique_ptr)";
        debug(os, t.get(), true);
    }

    template <typename T>
    void write_impl(std::ostream& os, const std::shared_ptr<T>& t)
    {
        os << "(std::shared_ptr)";
        debug(os, t.get(), true);
    }
    
    template <typename T>
    void write_impl(std::ostream& os, const std::weak_ptr<T>& t)
    {
        os << "(std::weak_ptr)";
        debug(os, t.lock().get(), true);
    }

	// Dispatches to the appropriate write_impl.
	constexpr auto write = [](std::ostream & os, auto&& t) -> void
	{
		write_impl(os, t);
	};
} // namespace refl::detail

// Custom reflection information for 
// some common built-in types (std::basic_string, std::tuple, std::pair).

#ifndef REFL_NO_STD_SUPPORT

REFL_TYPE(std::exception, debug{ refl::detail::write })
	REFL_FUNC(what, property{ })
REFL_END

REFL_TYPE(std::string, debug{ refl::detail::write })
    REFL_FUNC(size, property{ })
    REFL_FUNC(data, property{ })
REFL_END

REFL_TEMPLATE(
    (typename Elem, typename Traits, typename Alloc), 
    (std::basic_string<Elem, Traits, Alloc>), 
    debug{ refl::detail::write })
    REFL_FUNC(size, property{ })
    REFL_FUNC(data, property{ })
REFL_END

REFL_TEMPLATE(
    (typename... Ts),
    (std::tuple<Ts...>),
    debug{ refl::detail::write })
REFL_END

REFL_TEMPLATE(
    (typename T, typename D),
    (std::unique_ptr<T, D>),
    debug{ refl::detail::write })
REFL_END

REFL_TEMPLATE(
    (typename T),
    (std::shared_ptr<T>),
    debug{ refl::detail::write })
REFL_END

REFL_TEMPLATE(
    (typename K, typename V),
    (std::pair<K, V>),
    debug{ refl::detail::write })
REFL_END

#endif // REFL_NO_STD_SUPPORT

#ifndef REFL_NO_VARIADICS

#ifdef __GNUC__
#warning "refl-cpp variadics extensions are currently experimental"
#endif

#ifdef _MSC_VER
#pragma message ( "warning: refl-cpp variadics extensions are currently experimental" )
#endif

#define REFL_DETAIL_EXPAND(x) x
#define REFL_DETAIL_FOR_EACH_0(...)
#define REFL_DETAIL_FOR_EACH_1(what, x, ...) what(x)
#define REFL_DETAIL_FOR_EACH_2(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_1(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_3(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_2(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_4(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_3(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_5(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_4(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_6(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_5(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_7(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_6(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_8(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_7(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_9(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_8(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_10(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_9(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_11(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_10(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_12(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_11(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_13(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_12(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_14(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_13(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_15(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_14(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_16(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_15(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_17(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_16(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_18(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_17(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_19(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_18(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_20(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_19(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_21(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_20(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_22(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_21(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_23(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_22(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_24(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_23(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_25(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_24(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_26(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_25(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_27(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_26(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_28(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_27(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_29(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_28(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_30(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_29(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_31(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_30(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_32(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_31(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_33(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_32(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_34(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_33(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_35(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_34(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_36(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_35(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_37(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_36(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_38(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_37(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_39(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_38(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_40(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_39(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_41(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_40(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_42(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_41(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_43(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_42(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_44(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_43(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_45(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_44(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_46(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_45(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_47(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_46(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_48(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_47(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_49(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_48(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_50(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_49(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_51(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_50(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_52(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_51(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_53(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_52(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_54(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_53(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_55(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_54(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_56(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_55(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_57(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_56(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_58(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_57(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_59(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_58(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_60(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_59(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_61(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_60(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_62(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_61(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_63(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_62(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_64(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_63(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_65(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_64(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_66(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_65(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_67(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_66(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_68(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_67(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_69(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_68(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_70(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_69(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_71(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_70(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_72(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_71(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_73(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_72(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_74(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_73(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_75(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_74(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_76(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_75(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_77(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_76(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_78(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_77(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_79(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_78(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_80(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_79(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_81(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_80(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_82(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_81(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_83(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_82(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_84(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_83(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_85(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_84(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_86(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_85(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_87(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_86(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_88(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_87(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_89(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_88(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_90(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_89(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_91(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_90(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_92(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_91(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_93(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_92(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_94(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_93(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_95(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_94(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_96(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_95(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_97(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_96(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_98(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_97(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_99(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_98(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_100(what, x, ...) what(x) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_99(what, __VA_ARGS__))

#define REFL_DETAIL_FOR_EACH_NARG(...) REFL_DETAIL_FOR_EACH_NARG_(__VA_ARGS__, REFL_DETAIL_FOR_EACH_RSEQ_N())
#define REFL_DETAIL_FOR_EACH_NARG_(...) REFL_DETAIL_EXPAND(REFL_DETAIL_FOR_EACH_ARG_N(__VA_ARGS__))
#define REFL_DETAIL_FOR_EACH_ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, N, ...) N
#define REFL_DETAIL_FOR_EACH_RSEQ_N() 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
#define REFL_DETAIL_CONCATENATE(x, y) x##y
#define REFL_DETAIL_FOR_EACH_(N, what, ...) REFL_DETAIL_EXPAND(REFL_DETAIL_CONCATENATE(REFL_DETAIL_FOR_EACH_, N)(what, __VA_ARGS__))
#define REFL_DETAIL_FOR_EACH(what, ...) REFL_DETAIL_FOR_EACH_(REFL_DETAIL_FOR_EACH_NARG(__VA_ARGS__), what, __VA_ARGS__)

// Intellisense does not work nicely with passing variadic parameters (for the attributes)
// through all of the macro expansions and causes differently named member declarations to be 
// used during code inspection.
#ifdef __INTELLISENSE__

#define REFL_DETAIL_EX_1_type(X, ...) REFL_TYPE(X)
#define REFL_DETAIL_EX_1_field(X, ...) REFL_FIELD(X)
#define REFL_DETAIL_EX_1_func(X, ...) REFL_FUNC(X)

#else

#define REFL_DETAIL_EX_1_type(...) REFL_TYPE(__VA_ARGS__)
#define REFL_DETAIL_EX_1_field(...) REFL_FIELD(__VA_ARGS__)
#define REFL_DETAIL_EX_1_func(...) REFL_FUNC(__VA_ARGS__)

#endif

#define REFL_DETAIL_EX_(Specifier, ...) REFL_DETAIL_EX_1_##Specifier __VA_ARGS__
#define REFL_AUTO(...) REFL_DETAIL_FOR_EACH(REFL_DETAIL_EX_, __VA_ARGS__) REFL_END

#endif // REFL_NO_VARIADICS

#endif // REFL_PREPROCESSOR

#endif // REFL_INCLUDE_HPP
